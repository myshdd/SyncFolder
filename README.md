````markdown
# SyncFolder.ps1

Скрипт PowerShell для синхронизации двух папок с поддержкой:

- одностороннего и двустороннего режима;
- разных режимов сравнения файлов;
- фильтрации файлов по маскам (включение/исключение);
- исключения подпапок;
- конфигурации через `settings.json` (режим по умолчанию);
- логирования в файл с ротацией;
- стандартных `-WhatIf` / `-Confirm` (SupportsShouldProcess).

---

## Возможности

- **Направления синхронизации**
  - `LeftToRight` — из `SourcePath` в `DestinationPath`;
  - `RightToLeft` — из `DestinationPath` в `SourcePath`;
  - `Both` — двусторонняя синхронизация (два прохода).

- **Режимы сравнения файлов (`CompareMode`)**
  - `TimeAndSize` — по дате изменения и размеру (быстро, по умолчанию);
  - `ContentHash` — по хэшу содержимого (надёжнее, но медленнее).

- **Фильтрация**
  - `ExcludeDirectories` — исключение целых подпапок;
  - `IncludePatterns` — какие файлы включать (маски, как в PowerShell: `*.pdf`, `*.docx`);
  - `ExcludePatterns` — какие файлы исключать (например, `~*`, `*.tmp`, `*.bak`).

- **Удаление файлов**
  - Односторонняя синхронизация: удаляет «лишние» файлы в принимающей стороне.
  - Двусторонняя синхронизация: поведение управляется параметром `TwoWayDeletionSide`.

- **Конфигурация**
  - Основной режим — через `settings.json` рядом со скриптом;
  - Можно указать другой конфиг через параметр `-SettingsPath`.

- **Логирование**
  - Параметр `LogPath`:
    - фактический лог-файл на день: `<имя>-YYYY-MM-DD<расширение>`;
  - каждая строка содержит `RunId` запуска;
  - ротация логов по числу дней (`LogRetentionDays`).

- **Стандартные механизмы PowerShell**
  - `-WhatIf` — показать действия, не выполняя их;
  - `-Confirm` — запрашивать подтверждение перед выполнением.

---

## Требования

- PowerShell:
  - Windows PowerShell 5.1 **или**
  - PowerShell 7.x+
- Права на чтение и запись в синхронизируемых папках.
- Для логирования — права на запись в каталог логов.

---

## Установка

1. Скопируйте `syncfolder.ps1` и `settings.schema.json` в нужную директорию (например, `D:\DEV\Powershell\SyncFolder`).
2. Создайте (или отредактируйте) `settings.json` в той же директории.
3. При необходимости добавьте путь к скрипту в `PATH`.
4. Убедитесь, что политика выполнения позволяет запускать локальные скрипты:

   ```powershell
   Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
   ```
````

5. Если скрипт был скачан из интернета, снимите «блокировку» один раз:

   ```powershell
   Unblock-File .\syncfolder.ps1
   ```

---

## Настройки: `settings.json` и схема

### Автоматическое использование `settings.json`

При запуске:

```powershell
.\syncfolder.ps1
```

скрипт автоматически ищет файл `settings.json` в той же директории, где находится сам скрипт (`$PSScriptRoot`). Если файл найден, он используется как основной источник настроек.

Если конфигурационный файл находится в другом месте, можно указать его явно:

```powershell
.\syncfolder.ps1 -SettingsPath "D:\Configs\my_sync_settings.json"
```

Параметры командной строки (если заданы) **перекрывают** значения из `settings.json`.

### Пример `settings.json`

```json
{
  "$schema": "./settings.schema.json",
  "SourcePath": "C:\\test_dir\\Project\\MyApp",
  "DestinationPath": "C:\\test_dir\\Backup\\MyApp",
  "SyncDirection": "Both",
  "CompareMode": "TimeAndSize",
  "ExcludeDirectories": [".git", "node_modules", ".vs", "bin", "obj"],
  "IncludePatterns": ["*.pdf"],
  "ExcludePatterns": ["~*", "*.tmp", "*.bak"],
  "LogPath": "C:\\test_dir\\Logs\\syncfolder.log",
  "LogRetentionDays": 7,
  "TwoWayDeletionSide": "Destination"
}
```

### Схема настроек: `settings.schema.json`

Файл `settings.schema.json` описывает структуру `settings.json` и служит для автодополнения и валидации в редакторах (VS Code и др.).

Ключевые поля:

- `SourcePath` (`string`)
  Путь к исходной папке (левая папка).

- `DestinationPath` (`string`)
  Путь к папке назначения (правая папка).

- `SyncDirection` (`"LeftToRight" | "RightToLeft" | "Both"`)
  Направление синхронизации.

- `CompareMode` (`"TimeAndSize" | "ContentHash"`)
  Режим сравнения файлов:
  - `TimeAndSize` — по дате и размеру;
  - `ContentHash` — по SHA256 хэшу.

- `ExcludeDirectories` (`string[]`)
  Список имён подпапок, полностью исключаемых из синхронизации (по **первому сегменту пути** от корня).

- `IncludePatterns` (`string[]`)
  Маски файлов, которые нужно включить:
  - если массив пустой или не задан — включаются **все** файлы (кроме попавших под `ExcludePatterns`);
  - если задан — включаются только файлы, имя которых совпадает хотя бы с одной маской.

- `ExcludePatterns` (`string[]`)
  Маски файлов, которые нужно исключить:
  - при пустом `IncludePatterns` — исключаются любые файлы, совпадающие с этими масками;
  - при непустом `IncludePatterns` — из подходящих по `IncludePatterns` дополнительно исключаются совпавшие с `ExcludePatterns`.

- `LogPath` (`string`)
  Базовый путь к лог-файлу.
  Фактический лог за день будет иметь вид:
  `<basename>-YYYY-MM-DD<ext>` (например, `syncfolder-2026-01-28.log`).

- `LogRetentionDays` (`integer >= 0`)
  Число дней хранения логов:
  - `0` или отсутствие — не удалять старые логи;
  - `> 0` — логи старше указанного числа дней удаляются.

- `TwoWayDeletionSide` (`"None" | "Source" | "Destination"`)
  Управляет удалением файлов при двусторонней синхронизации (`SyncDirection = "Both"`):
  - `None` — никогда ничего не удалять (только копирование/обновление);
  - `Source` — **мастер левая папка** (`SourcePath`), удаление включено только на стороне назначения (`DestinationPath`);
  - `Destination` — **мастер правая папка** (`DestinationPath`), удаление включено только на стороне источника (`SourcePath`).

---

## Параметры командной строки

```powershell
.\syncfolder.ps1 `
    [-SourcePath <string>] `
    [-DestinationPath <string>] `
    [-SyncDirection <LeftToRight|RightToLeft|Both>] `
    [-ExcludeDirectories <string[]>] `
    [-CompareMode <TimeAndSize|ContentHash>] `
    [-IncludePatterns <string[]>] `
    [-ExcludePatterns <string[]>] `
    [-LogPath <string>] `
    [-LogRetentionDays <int>] `
    [-TwoWayDeletionSide <None|Source|Destination>] `
    [-SettingsPath <string>] `
    [-WhatIf] [-Confirm]
```

- Если параметр **задан и в командной строке, и в `settings.json`**, приоритет у командной строки.
- `-WhatIf` / `-Confirm` работают стандартно через `SupportsShouldProcess`.

---

## Логика работы при разных настройках

### 1. Режимы синхронизации (`SyncDirection`)

#### 1.1. `LeftToRight`

- Источник: `SourcePath`.
- Получатель: `DestinationPath`.
- Действия:
  - копируются новые файлы из Source в Destination;
  - обновляются изменённые файлы (сравнение по `CompareMode`);
  - **удаляются** файлы в Destination, которых нет в Source;
  - **удаляются пустые директории** в Destination, если их нет в Source.
- Все действия учитывают:
  - `ExcludeDirectories`;
  - `IncludePatterns` + `ExcludePatterns`.

#### 1.2. `RightToLeft`

- Источник: `DestinationPath`.
- Получатель: `SourcePath`.
- Аналогично `LeftToRight`, только стороны поменяны местами:
  - копирование «справа налево»;
  - удаление лишнего в Source.

#### 1.3. `Both` (двусторонняя синхронизация)

Выполняется **два прохода**:

1. `SourcePath → DestinationPath`;
2. `DestinationPath → SourcePath`.

Для каждого прохода:

- новые файлы копируются;
- изменённые файлы обновляются (по `CompareMode`);
- возможность удаления управляется параметром `TwoWayDeletionSide`.

##### Вариант A: `TwoWayDeletionSide = "None"`

- Удаление **полностью отключено**:
  - ни на одной стороне файлы не удаляются;
  - только копирование/обновление.
- Подходит, если:
  - нужно «слить» две папки в общую копию;
  - есть риск случайных удалений.

##### Вариант B: `TwoWayDeletionSide = "Source"`

- Считается, что **левая папка (SourcePath)** — «мастер».
- Логика:
  1. Проход `Source → Destination`, **удаление включено**:
     - Destination приводится к тому, что есть в Source;
     - файлы, которых нет в Source (с учётом фильтров), **удаляются** в Destination.
  2. Проход `Destination → Source`, **удаление выключено**:
     - позволяет перенести на Source файлы, которые есть только в Destination (первоначальное выравнивание);
     - но дальнейшие удаления «влияют» только из Source в Destination, а не наоборот.

- Проще всего думать так:
  - «что есть в Source — должно быть и в Destination»;
  - «если исчезло из Source — рано или поздно будет удалено в Destination»;
  - «удаления в Destination **не** приводят к удалению в Source, а исчезнувшие там файлы могут восстановиться из Source».

##### Вариант C: `TwoWayDeletionSide = "Destination"`

- Считается, что **правая папка (DestinationPath)** — «мастер».
- Логика симметрична предыдущей:
  1. Проход `Source → Destination`, **удаление выключено**;
  2. Проход `Destination → Source`, **удаление включено**:
     - Source приводится к виду Destination.

- Удобно, если Backup/правый каталог — основная эталонная копия.

> Важно:
> Скрипт **не ведёт историю** изменений и не хранит «тумбстоуны».
> Поэтому полностью симметричное «удаление в обе стороны» без базы состояния не реализовано по умолчанию: всегда есть одна сторона, которая считается приоритетной при удалениях (либо отключены удаление вообще).

---

## Режимы сравнения файлов (`CompareMode`)

### `TimeAndSize` (по умолчанию)

- Сравниваются:
  - дата последнего изменения (`LastWriteTime`);
  - размер файла в байтах (`Length`).
- Быстрый и подходящий для:
  - регулярной/частой синхронизации;
  - больших объёмов данных.
- Редкие теоретические случаи, когда содержимое отличается, но дата/размер совпадают, не будут обнаружены.

### `ContentHash`

- Сравниваются хэши содержимого (SHA256) для каждого файла.
- Обеспечивает:
  - гарантированное обнаружение изменений в содержимом.
- Может быть значительно медленнее:
  - особенно на больших файлах и больших деревьях каталогов.

Рекомендации:

- Для «ежедневной» синхронизации — `TimeAndSize`.
- Для первичного глубокого выравнивания или проверки целостности — `ContentHash`.

---

## Фильтрация файлов и папок

### Исключение подпапок (`ExcludeDirectories`)

`ExcludeDirectories` содержит имена подпапок, которые нужно полностью исключить из синхронизации.

Механика:

- сравнивается **первый сегмент** относительного пути от корня;
- если он совпадает с элементом `ExcludeDirectories`, весь этот подкаталог игнорируется.

Пример:

```text
C:\Projects\MyApp\
  .git\
  src\
    Module1\
  node_modules\
```

```json
"ExcludeDirectories": [ ".git", "node_modules" ]
```

Исключаются:

- `...\MyApp\.git\...`
- `...\MyApp\node_modules\...`

`src\` и её содержимое синхронизируются.

### Включение по маскам (`IncludePatterns`)

`IncludePatterns` — список масок (как в PowerShell):

- `["*.pdf", "*.docx"]` — только PDF и DOCX;
- `[]` (или не задано) — включать все расширения.

### Исключение по маскам (`ExcludePatterns`)

`ExcludePatterns` — список масок для исключения (аналогично `-Exclude` в PowerShell):

- `["~*", "*.tmp", "*.bak"]` — игнорировать временные файлы, резервные копии и т.п.

### Совместная работа `IncludePatterns` и `ExcludePatterns`

- Если `IncludePatterns` **пустой / не задан**:
  - включаются **все файлы**, которые:
    - не находятся в исключённых подпапках (`ExcludeDirectories`);
    - **не совпадают** ни с одной маской из `ExcludePatterns`.

- Если `IncludePatterns` **задан**:
  - включаются только файлы, которые:
    - находятся вне `ExcludeDirectories`;
    - совпали хотя бы с одной маской из `IncludePatterns`;
    - **не совпали** ни с одной маской из `ExcludePatterns`.

Во всех случаях:

- Файл, исключённый по маске (`ExcludePatterns`) или из-за папки (`ExcludeDirectories`), для скрипта «невидим»:
  - он не будет скопирован;
  - не будет удалён;
  - не будет участвовать в сравнении при определении «лишних» файлов.

---

## Логирование и ротация логов

### Формирование лог-файлов

Если задан `LogPath`, например:

```json
"LogPath": "C:\\test_dir\\Logs\\syncfolder.log"
```

то скрипт:

1. Выделяет каталог (`C:\test_dir\Logs`), имя файла (`syncfolder.log`), базовое имя (`syncfolder`) и расширение (`.log`).
2. Формирует **фактический** путь к лог-файлу за текущий день:

   ```text
   C:\test_dir\Logs\syncfolder-YYYY-MM-DD.log
   ```

3. Если каталога логов нет — создаёт его.
4. При каждом запуске генерирует `RunId` (например, `20260128-095934-8080`), который пишется в каждую строку лога.

Формат строки лога:

```text
[YYYY-MM-DD HH:MM:SS] [RUN:RunId] [LEVEL] Message
```

Уровни:

- `INFO` — общая информация (старт/конец скрипта, режим и т.п.);
- `ACTION` — реальные действия (копирование, удаление, создание папок);
- `WARN` — потенциальные проблемы (можно добавить при необходимости);
- `ERROR` — ошибки.

### Ротация логов (`LogRetentionDays`)

Если `LogRetentionDays > 0`, скрипт при запуске:

1. Рассчитывает дату отсечения: `Today - LogRetentionDays`.
2. В каталоге логов ищет файлы, удовлетворяющие шаблону:

   ```text
   <basename>-*<ext>
   ```

   (например, `syncfolder-*.log`).

3. Удаляет те, у которых `LastWriteTime.Date < cutoff`.

Если `LogRetentionDays = 0` или не задан, ротация не выполняется.

---

## Примеры

### 1. Базовый запуск (при наличии `settings.json` рядом со скриптом)

```powershell
.\syncfolder.ps1
```

Используются значения из `settings.json`.

### 2. Запуск с предпросмотром (`-WhatIf`)

```powershell
.\syncfolder.ps1 -WhatIf
```

Показывает, какие действия были бы выполнены (в консоль и лог), но **ничего не делает**.

### 3. Односторонняя синхронизация слева направо с настройками из файла

`settings.json`:

```json
{
  "SourcePath": "C:\\Data\\Source",
  "DestinationPath": "D:\\Backups\\SourceBackup",
  "SyncDirection": "LeftToRight",
  "CompareMode": "TimeAndSize"
}
```

Запуск:

```powershell
.\syncfolder.ps1
```

Результат:

- `D:\Backups\SourceBackup` становится зеркалом `C:\Data\Source` (с учётом фильтров и исключений).

### 4. Двусторонняя синхронизация без удаления

```json
{
  "SourcePath": "C:\\Data\\A",
  "DestinationPath": "D:\\Data\\B",
  "SyncDirection": "Both",
  "TwoWayDeletionSide": "None"
}
```

Поведение:

- Все уникальные файлы из A копируются в B;
- Все уникальные файлы из B — в A;
- Удаления нигде не происходит.

### 5. Двусторонняя синхронизация с приоритетом Source

```json
{
  "SourcePath": "C:\\Main\\Data",
  "DestinationPath": "D:\\Mirror\\Data",
  "SyncDirection": "Both",
  "TwoWayDeletionSide": "Source"
}
```

Поведение:

- `Destination` (D:\Mirror\Data) **следует** за `Source`:
  - файлы, удалённые в Source, будут удалены в Destination;
  - файлы, удалённые в Destination, могут восстановиться из Source;
- при этом есть второй проход `Destination → Source` без удалений, позволяющий один раз «слить» уникальные файлы, но дальше именно Source задаёт «истину» по удалению.

### 6. Синхронизация только PDF, с исключением временных файлов и логированием

```json
{
  "SourcePath": "C:\\Docs\\Current",
  "DestinationPath": "D:\\Docs\\Archive",
  "SyncDirection": "LeftToRight",
  "CompareMode": "ContentHash",
  "IncludePatterns": ["*.pdf"],
  "ExcludePatterns": ["~*", "*.tmp", "*.bak"],
  "LogPath": "C:\\Logs\\syncfolder.log",
  "LogRetentionDays": 14
}
```

Поведение:

- Синхронизуются только файлы `*.pdf`;
- Временные/служебные файлы по маскам не трогаются;
- Сравнение по содержимому (SHA256);
- Логи по дням, хранятся 14 дней.

---

## Типичные ошибки и FAQ

### 1. «Исходная папка не существует: ...»

**Причина:** Путь в `SourcePath` некорректен (опечатка, папка не создана).

**Проверка:**

```powershell
Test-Path "C:\test_dir\Project\MyApp" -PathType Container
```

**Решение:**

- Исправить `SourcePath` в `settings.json` или параметрах;
- Убедиться, что папка существует.

---

### 2. «Файл настроек не найден: ...»

**Причина:** Указан неверный `-SettingsPath` или отсутствует `settings.json` рядом со скриптом.

**Решение:**

- Проверить путь к файлу настроек;
- При запуске без параметров убедиться, что `settings.json` лежит рядом с `syncfolder.ps1`.

---

### 3. Ошибки парсинга JSON (settings.json)

Сообщения вида:

- «Не удалось прочитать или разобрать JSON…»;
- ошибки синтаксиса JSON.

**Причина:** Некорректный формат JSON (лишняя запятая, неправильные кавычки и т.п.).

**Решение:**

- Проверить `settings.json` в JSON-валидаторе;
- В VS Code подключить схему:

  ```json
  {
    "$schema": "./settings.schema.json",
    ...
  }
  ```

- Исправить подсвеченные ошибки.

---

### 4. Логи не создаются / создаётся только базовый файл `syncfolder.log`

В новой версии:

- фактический лог на день — `syncfolder-YYYY-MM-DD.log`;
- файл `syncfolder.log` мог остаться от старой версии, сейчас не используется.

**Проверить:**

- `LogPath` указан в `settings.json`;
- есть ли в каталоге файл с сегодняшней датой.

---

### 5. Файлы неожиданно удалились в одной из папок

**Причина:**
Используется:

- односторонняя синхронизация (`LeftToRight` / `RightToLeft`) — по умолчанию **удаляет** лишние файлы в принимающей стороне;
  **ИЛИ**
- двусторонняя синхронизация с `TwoWayDeletionSide = "Source"` или `"Destination"` — удаление включено на одной из сторон.

**Решение:**

- Для «мягкого» объединения без удалений использовать:
  - `SyncDirection: "Both"`
  - `TwoWayDeletionSide: "None"`

---

### 6. Файлы с определёнными расширениями не копируются

**Причина:** Основные варианты:

- не подходят под `IncludePatterns`;
- попадают под `ExcludePatterns`;
- лежат в подпапках из `ExcludeDirectories`.

**Проверка:**

- Убедиться, что имя файла:
  - **совпадает** хотя бы с одной маской из `IncludePatterns` (если `IncludePatterns` не пустой);
  - **не совпадает** ни с одной маской из `ExcludePatterns`.

**Пример:**

- Файл `_Корзина #3.pdf.bak`;
- `ExcludePatterns: ["*.bak"]`.

Такой файл будет игнорироваться полностью:
не копируется, не участвует в сравнении и не удаляется как «лишний».

---

### 7. Медленная работа при `CompareMode = ContentHash`

**Причина:** Каждый файл читается целиком для вычисления SHA256.

**Решение:**

- Для регулярной синхронизации использовать `TimeAndSize`;
- `ContentHash` — только при необходимости точной проверки.

---

### 8. Поведение `-WhatIf` и `-Confirm`

- `-WhatIf`:
  - все действия проходят через `ShouldProcess`;
  - фактически **ничего не создаётся/не удаляется/не копируется**;
  - в консоли выводятся сообщения `What if: Performing the operation ...`, плюс логируются действия.

- `-Confirm`:
  - перед каждым действием, помеченным `ShouldProcess`, запрашивается подтверждение.

---

## Лицензия

Укажите здесь выбранную лицензию вашего проекта (например, MIT, Apache 2.0 и т.д.).

```

```
